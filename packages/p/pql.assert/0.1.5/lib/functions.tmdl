/// DAX Expression Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against DAX expression best practices
/// Asserts that column references in DAX expressions should be fully qualified.
/// Using fully qualified column references (Table[Column]) makes it easier to distinguish between columns and measures, and helps avoid certain errors.
function 'PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasUnqualifiedColumnRef = 
		                // Check for unqualified column references in the expression
		                // This is a simplified check - looks for [ColumnName] not preceded by a table name
		                // Pattern: spaces or operators followed by [ but not preceded by alphanumeric/underscore
		                NOT ISBLANK(_Expression) 
		                && (
		                    CONTAINSSTRING(_Expression, " [") 
		                    || CONTAINSSTRING(_Expression, "([") 
		                    || CONTAINSSTRING(_Expression, ",[")
		                    || LEFT(_Expression, 1) = "["
		                )
		                && NOT CONTAINSSTRING(_Expression, "'[") // Exclude table names with brackets
		            RETURN _HasUnqualifiedColumnRef
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES WITH UNQUALIFIED COLUMN REFERENCES FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "ALL COLUMN REFERENCES ARE FULLY QUALIFIED"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Column references should be fully qualified",
		        "Expected", "All column references should be fully qualified (Table[Column])",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Using fully qualified column references makes it easier to distinguish between column and measure references, and also helps avoid certain errors. Reference: https://www.elegantbi.com/post/top10bestpractices"
	    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that measures should use TREATAS instead of INTERSECT for virtual relationships.
/// The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships.
function 'PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasIntersect = 
		                // Check for INTERSECT function usage (case-insensitive)
		                NOT ISBLANK(_Expression) 
		                && (
		                    CONTAINSSTRING(UPPER(_Expression), "INTERSECT(")
		                    || CONTAINSSTRING(UPPER(_Expression), "INTERSECT (")
		                )
		            RETURN _HasIntersect
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES USING INTERSECT FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "NO MEASURES USE INTERSECT"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Use the TREATAS function instead of INTERSECT",
		        "Expected", "Measures should use TREATAS instead of INTERSECT for virtual relationships",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships. Reference: https://www.sqlbi.com/articles/propagate-filters-using-treatas-in-dax/ Severity: Medium (2)."
	    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Runs all DAX expression best practice checks.
/// This function executes all DAX expression validation rules and returns combined results.
function 'PQL.Assert.BP.CheckDAXExpressions' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences(),
		        PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// Error Prevention Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against error prevention best practices
/// Asserts that relationship columns should be of the same data type.
/// Columns used in a relationship should be of the same data type. Having columns within a relationship which are of different data types may lead to various issues.
function 'PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships' =
		() =>
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    
		    // Create a lookup for column data types
		    VAR _ColumnDataTypes = 
		        SUMMARIZE(
		            _Columns,
		            [Table],
		            [Name],
		            [DataType]
		        )
		    
		    // Check each relationship for data type mismatches
		    VAR _ViolatingRelationships = 
		        FILTER(
		            _Relationships,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]
		            
		            // Get data type of FromColumn
		            VAR _FromDataType = 
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _FromTable && [Name] = _FromColumn
		                    ),
		                    [DataType]
		                )
		            
		            // Get data type of ToColumn
		            VAR _ToDataType = 
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _ToTable && [Name] = _ToColumn
		                    ),
		                    [DataType]
		                )
		            
		            // Check if data types are different
		            RETURN 
		                NOT ISBLANK(_FromDataType) 
		                && NOT ISBLANK(_ToDataType)
		                && _FromDataType <> _ToDataType
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingRelationships)
		    
		    VAR _RelationshipsList = 
		        CONCATENATEX(
		            _ViolatingRelationships,
		            [FromTable] & "[" & [FromColumn] & "] -> " & [ToTable] & "[" & [ToColumn] & "]",
		            ", ",
		            [FromTable], ASC,
		            [FromColumn], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "RELATIONSHIPS WITH MISMATCHED DATA TYPES FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _RelationshipsList,
		            "ALL RELATIONSHIP COLUMNS HAVE MATCHING DATA TYPES"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Error Prevention] Relationship columns should be of the same data type",
		        "Expected", "All relationship columns should have matching data types",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Columns used in a relationship should be of the same data type. Ideally, they will be of integer data type. Having columns within a relationship which are of different data types may lead to various issues including slower performance and unexpected query results. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Runs all error prevention best practice checks.
/// This function executes all error prevention validation rules and returns combined results.
function 'PQL.Assert.BP.CheckErrorPrevention' =
		() =>
		    PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships()
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// Formatting Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against formatting best practices
/// Asserts that visible measures should have their format string property assigned.
/// Measures without format strings may display inconsistently and make reports harder to understand.
function 'PQL.Assert.BP.ShouldProvideFormatStringForMeasures' =
		() =>
		    VAR _ViewMeasures = INFO.VIEW.MEASURES()
		    VAR _Measures = INFO.MEASURES()
		    VAR _Tables = INFO.VIEW.TABLES()
		    
		    // Create a lookup for hidden tables
		    VAR _HiddenTables = 
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )
		    
		    // Check measures for missing format strings
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _ViewMeasures,
		            VAR _TableName = [Table]
		            VAR _MeasureID = [ID]
		            
		            // Get FormatString from INFO.MEASURES()
		            VAR _FormatString = 
		                MAXX(
		                    FILTER(
		                        _Measures,
		                        [ID] = _MeasureID
		                    ),
		                    [FormatString]
		                )
		            
		            // Check if table is hidden
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0
		            
		            // Measure is on a visible table and has no format string
		            RETURN 
		                NOT _TableIsHidden
		                && (ISBLANK(_FormatString) || _FormatString = "")
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingMeasures)
		    
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "MEASURES WITHOUT FORMAT STRING FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _MeasuresList,
		            "ALL VISIBLE MEASURES HAVE FORMAT STRINGS ASSIGNED"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Formatting] Provide format string for measures",
		        "Expected", "All visible measures should have format strings assigned",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Visible measures should have their format string property assigned. Measures without format strings may display inconsistently and make reports harder to understand. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Asserts that numeric columns should have SummarizeBy set to None.
/// Numeric columns with SummarizeBy enabled may cause accidental aggregation in reports. Users should create explicit measures instead.
function 'PQL.Assert.BP.ShouldNotSummarizeNumericColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    
		    // Create a lookup for hidden tables
		    VAR _HiddenTables = 
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )
		    
		    // Check numeric columns with SummarizeBy not set to None
		    VAR _ViolatingColumns = 
		        FILTER(
		            _Columns,
		            VAR _TableName = [Table]
		            VAR _DataType = [DataType]
		            VAR _IsHidden = [IsHidden]
		            VAR _SummarizeBy = [SummarizeBy]
		            
		            // Check if table is hidden
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0
		            
		            // Column is numeric (Int64, Decimal, or Double)
		            VAR _IsNumeric = 
		                _DataType = "Integer"
		                || _DataType = "Currency"
		                || _DataType = "Number"
		            
		            // Check if SummarizeBy is not set to None
		            RETURN 
		                _IsNumeric
		                && NOT _IsHidden
		                && NOT _TableIsHidden
		                && _SummarizeBy <> "None"
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)
		    
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "] (SummarizeBy: " & [SummarizeBy] & ")",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "NUMERIC COLUMNS WITH SUMMARIZE BY FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "ALL NUMERIC COLUMNS HAVE SUMMARIZE BY SET TO NONE"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Formatting] Do not summarize numeric columns",
		        "Expected", "Numeric columns should have SummarizeBy set to None",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Numeric columns (Int64, Decimal, Double) should have their SummarizeBy property set to None to avoid accidental aggregation in Power BI. Users should create explicit measures instead. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Runs all formatting best practice checks.
/// This function executes all formatting validation rules and returns combined results.
function 'PQL.Assert.BP.CheckFormatting' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldProvideFormatStringForMeasures(),
		        PQL.Assert.BP.ShouldNotSummarizeNumericColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// DAX Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against best practices and performance recommendations
/// Asserts that no bi-directional relationships exist on high-cardinality columns.
/// For high-cardinality columns (>1M distinct values), bi-directional relationships can impact performance.
function 'PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn' =
		() =>
		    VAR _CardinalityThreshold = 1000000
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _ColumnStats = COLUMNSTATISTICS()
		    VAR _BiDirectionalRels = 
		        FILTER(
		            _Relationships,
		            [CrossFilteringBehavior] = "BothDirections"
		        )
		    VAR _HighCardinalityBiDirRels = 
		        FILTER(
		            _BiDirectionalRels,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]
		            VAR _FromColumnCardinality = 
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _FromTable && [Column Name] = _FromColumn
		                    ),
		                    [Cardinality]
		                )
		            VAR _ToColumnCardinality = 
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _ToTable && [Column Name] = _ToColumn
		                    ),
		                    [Cardinality]
		                )
		            RETURN _FromColumnCardinality > _CardinalityThreshold || _ToColumnCardinality > _CardinalityThreshold
		        )
		    VAR _HighCardinalityCount = COUNTROWS(_HighCardinalityBiDirRels)
		    VAR _Passed = _HighCardinalityCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Avoid bi-directional relationships against high-cardinality columns",
		        "Expected", "No bi-directional relationships on high-cardinality columns (>1M)",
		        "Actual", IF(_HighCardinalityCount > 0, "BI-DIRECTIONAL RELATIONSHIPS ON HIGH-CARDINALITY COLUMNS FOUND (" & FORMAT(_HighCardinalityCount, "0") & ")", "NO HIGH-CARDINALITY BI-DIRECTIONAL RELATIONSHIPS"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid bi-directional relationships on high-cardinality columns (>1M distinct values) for better performance"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that auto-date tables should be removed.
/// Auto-date tables (DateTableTemplate_* and LocalDateTable_*) consume memory and should be disabled.
function 'PQL.Assert.BP.ShouldRemoveAutoDateTable' =
		() =>
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _AutoDateTableCount = 
		        COUNTROWS(
		            FILTER(
		                _Tables,
		                LEFT([Name], 18) = "DateTableTemplate_" || LEFT([Name], 15) = "LocalDateTable_"
		            )
		        )
		    VAR _Passed = _AutoDateTableCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Remove auto-date table",
		        "Expected", "No auto-date tables should exist in the model",
		        "Actual", IF(_AutoDateTableCount > 0, "AUTO-DATE TABLES FOUND (" & FORMAT(_AutoDateTableCount, "0") & ")", "NO AUTO-DATE TABLES"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using auto-date tables. Turn off auto-date table in Power BI Desktop settings to save memory"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that no columns use floating point data types.
/// The "Double" floating point data type should be avoided to prevent unpredictable roundoff errors and performance issues.
function 'PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _DoubleColumns = 
		        FILTER(
		            _Columns,
		            [DataType] = "Number"
		        )
		    VAR _DoubleColumnCount = COUNTROWS(_DoubleColumns)
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _DoubleColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _DoubleColumnCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _DoubleColumnCount > 0,
		            "NUMBER DATA TYPE COLUMNS FOUND (" & FORMAT(_DoubleColumnCount, "0") & "): " & _ColumnsList,
		            "NO NUMBER DATA TYPE COLUMNS"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Do not use floating point data types",
		        "Expected", "No columns should use Number data type",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using Number floating point data type, as it can result in unpredictable roundoff errors and decreased performance. Use Int64 or Decimal where appropriate (Decimal limited to 4 digits after decimal)"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that IsAvailableInMdx should be set to false on non-attribute hidden columns.
/// Hidden columns should have IsAvailableInMdx set to false for better performance.
function 'PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _ViolatingColumns = 
		        FILTER(
		            _Columns,
		            VAR _CurrentTable = [Table]
		            VAR _IsHidden = [IsHidden]
		            VAR _IsAvailableInMDX = [IsAvailableInMDX]
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(_Tables, [Name] = _CurrentTable && [IsHidden] = TRUE)
		                ) > 0
		            RETURN
		                _IsAvailableInMDX = TRUE
		                && (_IsHidden = FALSE && _TableIsHidden = FALSE)
		        )
		    VAR _ViolatingColumnCount = COUNTROWS(_ViolatingColumns)
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingColumnCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingColumnCount > 0,
		            "COLUMNS WITH ISAVAILABLEINMDX=TRUE FOUND (" & FORMAT(_ViolatingColumnCount, "0") & "): " & _ColumnsList,
		            "NO VIOLATING COLUMNS"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Set IsAvailableInMdx to false on non-attribute columns",
		        "Expected", "Hidden columns should have IsAvailableInMdx = false",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "To speed up processing time and conserve memory, attribute hierarchies should not be built for hidden columns. Set IsAvailableInMdx to false for better performance"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Runs all performance best practice checks.
/// This function executes all performance validation rules and returns combined results.
function 'PQL.Assert.BP.CheckPerformance' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn(),
		        PQL.Assert.BP.ShouldRemoveAutoDateTable(),
		        PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes(),
		        PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
