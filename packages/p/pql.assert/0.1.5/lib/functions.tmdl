/// DAX Assertion Library Functions
/// Publisher: PQL (Power Query Lint)
/// These functions provide a standardized way to write unit tests for DAX models
/// Basic Assertions - PQL.Assert namespace
function 'PQL.Assert.ShouldBeTrue' =
		(testName : STRING, actualCondition : BOOLEAN) =>
		    VAR _Passed = actualCondition = TRUE
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "TRUE",
		        "Actual", IF(actualCondition, "TRUE", "FALSE"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldBeFalse' =
		(testName : STRING, actualCondition : BOOLEAN) =>
		    VAR _Passed = actualCondition = FALSE
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "FALSE",
		        "Actual", IF(actualCondition, "TRUE", "FALSE"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is NULL (DAX BLANK()).
function 'PQL.Assert.ShouldBeNull' =
		(testName : STRING, actualValue : VARIANT) =>
		    VAR _Passed = ISBLANK(actualValue)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NULL",
		        "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is not NULL (not DAX BLANK()). Accepts both simple values and expressions.
function 'PQL.Assert.ShouldNotBeNull' =
		(testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
		    VAR _ActualResult = actualValue
		    VAR _Passed = NOT ISBLANK(_ActualResult)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NOT NULL",
		        "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is BLANK (empty string "").
function 'PQL.Assert.ShouldBeBlank' =
		(testName : STRING, actualValue : VARIANT) =>
		    VAR _Passed = NOT ISBLANK(actualValue) && actualValue = ""
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "BLANK (empty string)",
		        "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is not BLANK (not empty string "").
function 'PQL.Assert.ShouldNotBeBlank' =
		(testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
		    VAR _ActualResult = actualValue
		    VAR _Passed = ISBLANK(_ActualResult) || _ActualResult <> ""
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NOT BLANK (not empty string)",
		        "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is NULL or BLANK (BLANK() or empty string "").
function 'PQL.Assert.ShouldBeNullOrBlank' =
		(testName : STRING, actualValue : VARIANT) =>
		    VAR _Passed = ISBLANK(actualValue) || actualValue = ""
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NULL OR BLANK",
		        "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )

	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a value is not NULL and not BLANK (has actual content).
function 'PQL.Assert.ShouldNotBeNullOrBlank' =
		(testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
		    VAR _ActualResult = actualValue
		    VAR _Passed = NOT ISBLANK(_ActualResult) && _ActualResult <> ""
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NOT NULL AND NOT BLANK",
		        "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldEqual' =
		(testName : STRING, expected : VARIANT, actual : VARIANT) =>
		    VAR _Passed = expected = actual
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", FORMAT(expected, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldNotEqual' =
		(testName : STRING, notExpected : VARIANT, actual : VARIANT) =>
		    VAR _Passed = notExpected <> actual
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "NOT " & FORMAT(notExpected, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that two strings are exactly equal (case-sensitive comparison).
function 'PQL.Assert.ShouldEqualExactly' =
		(testName : STRING, expected : STRING, actual : STRING) =>
		    VAR _Passed = EXACT(expected, actual)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", expected,
		        "Actual", actual,
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldBeGreaterThan' =
		(testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
		    VAR _Passed = actual > threshold
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "> " & FORMAT(threshold, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldBeLessThan' =
		(testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
		    VAR _Passed = actual < threshold
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "< " & FORMAT(threshold, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a number is greater than or equal to an expected value.
function 'PQL.Assert.ShouldBeGreaterOrEqual' =
		(testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
		    VAR _Passed = actual >= threshold
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", ">= " & FORMAT(threshold, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a number is less than or equal to an expected value.
function 'PQL.Assert.ShouldBeLessOrEqual' =
		(testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
		    VAR _Passed = actual <= threshold
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "<= " & FORMAT(threshold, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.ShouldBeBetween' =
		(testName : STRING, lowerBound : DOUBLE, upperBound : DOUBLE, actual : DOUBLE) =>
		    VAR _Passed = actual >= lowerBound && actual <= upperBound
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", FORMAT(lowerBound, "") & " <= value <= " & FORMAT(upperBound, ""),
		        "Actual", FORMAT(actual, ""),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// String Assertions - PQL.Assert namespace
/// Asserts that a string starts with the specified prefix (case-insensitive).
function 'PQL.Assert.ShouldStartWith' =
		(testName : STRING, prefix : STRING, actual : STRING) =>
		    VAR _Passed = LEFT(UPPER(actual), LEN(prefix)) = UPPER(prefix)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Starts with '" & prefix & "'",
		        "Actual", actual,
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a string ends with the specified suffix (case-insensitive).
function 'PQL.Assert.ShouldEndWith' =
		(testName : STRING, suffix : STRING, actual : STRING) =>
		    VAR _Passed = RIGHT(UPPER(actual), LEN(suffix)) = UPPER(suffix)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Ends with '" & suffix & "'",
		        "Actual", actual,
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a string contains the specified substring (case-insensitive).
function 'PQL.Assert.ShouldContainString' =
		(testName : STRING, substring : STRING, actual : STRING) =>
		    VAR _Passed = CONTAINSSTRING(actual, substring)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Contains '" & substring & "'",
		        "Actual", actual,
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a string matches a pattern (case-insensitive).
function 'PQL.Assert.ShouldMatch' =
		(testName : STRING, pattern : STRING, actual : STRING) =>
		    VAR _Passed = CONTAINSSTRING(actual, pattern)
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Matches '" & pattern & "'",
		        "Actual", actual,
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Col Assertions - PQL.Assert.Col namespace
/// Asserts that all values in a column are NULL (DAX BLANK()).
function 'PQL.Assert.Col.ShouldBeNull' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _NonNullCount = DISTINCTCOUNTNOBLANK(columnRef)
		    VAR _Passed = _NonNullCount = 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column is all NULL",
		        "Actual", IF(_Passed, "ALL NULL", "HAS NON-NULL VALUES (" & FORMAT(_NonNullCount, "0") & " distinct)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a column contains at least one non-NULL value (not DAX BLANK()).
function 'PQL.Assert.Col.ShouldNotBeNull' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _NonNullCount = DISTINCTCOUNTNOBLANK(columnRef)
		    VAR _Passed = _NonNullCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column has non-NULL values",
		        "Actual", IF(_Passed, "HAS VALUES (" & FORMAT(_NonNullCount, "0") & " distinct)", "ALL NULL"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that all values in a column are BLANK (empty string "" or NULL BLANK()). Fails if any non-blank values exist.
function 'PQL.Assert.Col.ShouldBeBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _NonBlankCount = COUNTAX(
		        VALUES(columnRef),
		        IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> "", 1, BLANK())
		    )
		    VAR _TotalCount = COUNTROWS(VALUES(columnRef))
		    VAR _Passed = _NonBlankCount = 0 && _TotalCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column is all BLANK (empty string or NULL)",
		        "Actual", IF(_Passed, "ALL BLANK", "HAS NON-BLANK VALUES (" & FORMAT(_NonBlankCount, "0") & " non-blank)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that all values in a column are non-BLANK (not empty string "" and not NULL BLANK()). Fails if any blank values exist.
function 'PQL.Assert.Col.ShouldNotBeBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _BlankCount = COUNTBLANK(columnRef)
		    VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
		    VAR _Passed = _BlankCount = 0 && _TotalCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column has no BLANK values (all non-empty and non-NULL)",
		        "Actual", IF(_Passed, "NO BLANK VALUES", "HAS BLANK VALUES (" & FORMAT(_BlankCount, "0") & " blank)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that all values in a column are NULL or BLANK (BLANK() or empty string ""). Fails if any values with content exist.
function 'PQL.Assert.Col.ShouldBeNullOrBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _NonEmptyCount = COUNTAX(
		        VALUES(columnRef),
		        IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> "", 1, BLANK())
		    )
		    VAR _TotalCount = COUNTROWS(VALUES(columnRef))
		    VAR _Passed = _NonEmptyCount = 0 && _TotalCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column is all NULL or BLANK",
		        "Actual", IF(_Passed, "ALL NULL/BLANK", "HAS VALUES (" & FORMAT(_NonEmptyCount, "0") & " non-empty)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that all values in a column are not NULL and not BLANK. Fails if any NULL or empty values exist.
function 'PQL.Assert.Col.ShouldNotBeNullOrBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _BlankCount = COUNTBLANK(columnRef)
		    VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
		    VAR _Passed = _BlankCount = 0 && _TotalCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column has no NULL or BLANK values (all values have content)",
		        "Actual", IF(_Passed, "NO NULL/BLANK VALUES", "HAS NULL/BLANK VALUES (" & FORMAT(_BlankCount, "0") & " empty)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that all values in a column are unique (no duplicates).
function 'PQL.Assert.Col.ShouldBeDistinct' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
		    VAR _DistinctCount = DISTINCTCOUNT(columnRef)
		    VAR _TotalCount = COUNTROWS(VALUES(columnRef))
		    VAR _Passed = _DistinctCount = _TotalCount
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "All values distinct",
		        "Actual", IF(_Passed, "ALL DISTINCT (" & FORMAT(_TotalCount, "0") & " rows)", "DUPLICATES FOUND (" & FORMAT(_DistinctCount, "0") & " distinct of " & FORMAT(_TotalCount, "0") & " rows)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.Col.ShouldExist' =
		(testName : STRING, tableName : STRING, columnName : STRING) =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Found = COUNTROWS(FILTER(_Columns, [Table] = tableName && [Name] = columnName)) > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Column '" & tableName & "[" & columnName & "]' exists",
		        "Actual", IF(_Found, "EXISTS", "NOT FOUND"),
		        "Passed", _Found
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Table Assertions - PQL.Assert.Table namespace
/// Asserts that a table has at least one row.
function 'PQL.Assert.Tbl.ShouldHaveRows' =
		(testName : STRING, tableRef : TABLE EXPR) =>
		    VAR _RowCount = COUNTROWS(tableRef)
		    VAR _Passed = _RowCount > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Table has rows",
		        "Actual", IF(_Passed, "HAS ROWS (" & FORMAT(_RowCount, "0") & ")", "EMPTY (0 rows)"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that a table has exactly the expected number of rows.
function 'PQL.Assert.Tbl.ShouldHaveRowCount' =
		(testName : STRING, tableRef : TABLE EXPR, expectedRowCount : INT64) =>
		    VAR _RowCount = COUNTROWS(tableRef)
		    VAR _Passed = _RowCount = expectedRowCount
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", FORMAT(expectedRowCount, "0") & " rows",
		        "Actual", FORMAT(_RowCount, "0") & " rows",
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.Tbl.ShouldHaveMoreRowsThan' =
		(testName : STRING, threshold : INT64, tableToCheck : TABLE) =>
		    VAR _RowCount = COUNTROWS(tableToCheck)
		    VAR _Passed = _RowCount > threshold
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "> " & FORMAT(threshold, "0"),
		        "Actual", FORMAT(_RowCount, "0"),
		        "Passed", _Passed
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

function 'PQL.Assert.Tbl.ShouldExist' =
		(testName : STRING, tableName : STRING) =>
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _Found = COUNTROWS(FILTER(_Tables, [Name] = tableName)) > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Table '" & tableName & "' exists",
		        "Actual", IF(_Found, "EXISTS", "NOT FOUND"),
		        "Passed", _Found
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Relationship Assertions - PQL.Assert.Relationship namespace
function 'PQL.Assert.Relationship.ShouldExist' =
		(testName : STRING, fromTable : STRING, fromColumn : STRING, toTable : STRING, toColumn : STRING) =>
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _Found = COUNTROWS(FILTER(_Relationships,
		        [FromTable] = fromTable && [FromColumn] = fromColumn &&
		        [ToTable] = toTable && [ToColumn] = toColumn)) > 0
		    RETURN ROW(
		        "TestName", testName,
		        "Expected", "Relationship '" & fromTable & "[" & fromColumn & "] -> " & toTable & "[" & toColumn & "]' exists",
		        "Actual", IF(_Found, "EXISTS", "NOT FOUND"),
		        "Passed", _Found
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Test Discovery Functions - PQL.Assert namespace
function 'PQL.Assert.RetrieveTests' =
		() =>
		    FILTER(INFO.FUNCTIONS("ORIGIN", "2"), OR(RIGHT([FUNCTION_NAME],5) = ".Test", RIGHT([FUNCTION_NAME],6) = ".Tests"))
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Retrieves tests filtered by environment. Looks for .{ENV}. or .ANY. in function names.
/// If environment is blank, returns all tests.
/// Supports any custom environment naming convention (DEV, TEST, PROD, UAT, STAGING, etc.)
function 'PQL.Assert.RetrieveTestsByEnvironment' =
		(environment: STRING) =>
		    VAR _EnvUpper = UPPER(environment)
		    RETURN
		        FILTER(
		            INFO.FUNCTIONS("ORIGIN", "2"),
		            (RIGHT([FUNCTION_NAME], 5) = ".Test" || RIGHT([FUNCTION_NAME], 6) = ".Tests")
		            && (
		                ISBLANK(_EnvUpper)
		                || CONTAINSSTRING(UPPER([FUNCTION_NAME]), "." & _EnvUpper & ".")
		                || CONTAINSSTRING(UPPER([FUNCTION_NAME]), ".ANY.")
		            )
		        )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5



/// DAX Expression Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against DAX expression best practices
/// Asserts that column references in DAX expressions should be fully qualified.
/// Using fully qualified column references (Table[Column]) makes it easier to distinguish between columns and measures, and helps avoid certain errors.
function 'PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasUnqualifiedColumnRef = 
		                // Check for unqualified column references in the expression
		                // This is a simplified check - looks for [ColumnName] not preceded by a table name
		                // Pattern: spaces or operators followed by [ but not preceded by alphanumeric/underscore
		                NOT ISBLANK(_Expression) 
		                && (
		                    CONTAINSSTRING(_Expression, " [") 
		                    || CONTAINSSTRING(_Expression, "([") 
		                    || CONTAINSSTRING(_Expression, ",[")
		                    || LEFT(_Expression, 1) = "["
		                )
		                && NOT CONTAINSSTRING(_Expression, "'[") // Exclude table names with brackets
		            RETURN _HasUnqualifiedColumnRef
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES WITH UNQUALIFIED COLUMN REFERENCES FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "ALL COLUMN REFERENCES ARE FULLY QUALIFIED"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Column references should be fully qualified",
		        "Expected", "All column references should be fully qualified (Table[Column])",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Using fully qualified column references makes it easier to distinguish between column and measure references, and also helps avoid certain errors. Reference: https://www.elegantbi.com/post/top10bestpractices"
	    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that measures should use TREATAS instead of INTERSECT for virtual relationships.
/// The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships.
function 'PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasIntersect = 
		                // Check for INTERSECT function usage (case-insensitive)
		                NOT ISBLANK(_Expression) 
		                && (
		                    CONTAINSSTRING(UPPER(_Expression), "INTERSECT(")
		                    || CONTAINSSTRING(UPPER(_Expression), "INTERSECT (")
		                )
		            RETURN _HasIntersect
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES USING INTERSECT FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "NO MEASURES USE INTERSECT"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Use the TREATAS function instead of INTERSECT",
		        "Expected", "Measures should use TREATAS instead of INTERSECT for virtual relationships",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships. Reference: https://www.sqlbi.com/articles/propagate-filters-using-treatas-in-dax/ Severity: Medium (2)."
	    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Runs all DAX expression best practice checks.
/// This function executes all DAX expression validation rules and returns combined results.
function 'PQL.Assert.BP.CheckDAXExpressions' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences(),
		        PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// Error Prevention Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against error prevention best practices
/// Asserts that relationship columns should be of the same data type.
/// Columns used in a relationship should be of the same data type. Having columns within a relationship which are of different data types may lead to various issues.
function 'PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships' =
		() =>
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    
		    // Create a lookup for column data types
		    VAR _ColumnDataTypes = 
		        SUMMARIZE(
		            _Columns,
		            [Table],
		            [Name],
		            [DataType]
		        )
		    
		    // Check each relationship for data type mismatches
		    VAR _ViolatingRelationships = 
		        FILTER(
		            _Relationships,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]
		            
		            // Get data type of FromColumn
		            VAR _FromDataType = 
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _FromTable && [Name] = _FromColumn
		                    ),
		                    [DataType]
		                )
		            
		            // Get data type of ToColumn
		            VAR _ToDataType = 
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _ToTable && [Name] = _ToColumn
		                    ),
		                    [DataType]
		                )
		            
		            // Check if data types are different
		            RETURN 
		                NOT ISBLANK(_FromDataType) 
		                && NOT ISBLANK(_ToDataType)
		                && _FromDataType <> _ToDataType
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingRelationships)
		    
		    VAR _RelationshipsList = 
		        CONCATENATEX(
		            _ViolatingRelationships,
		            [FromTable] & "[" & [FromColumn] & "] -> " & [ToTable] & "[" & [ToColumn] & "]",
		            ", ",
		            [FromTable], ASC,
		            [FromColumn], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "RELATIONSHIPS WITH MISMATCHED DATA TYPES FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _RelationshipsList,
		            "ALL RELATIONSHIP COLUMNS HAVE MATCHING DATA TYPES"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Error Prevention] Relationship columns should be of the same data type",
		        "Expected", "All relationship columns should have matching data types",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Columns used in a relationship should be of the same data type. Ideally, they will be of integer data type. Having columns within a relationship which are of different data types may lead to various issues including slower performance and unexpected query results. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Runs all error prevention best practice checks.
/// This function executes all error prevention validation rules and returns combined results.
function 'PQL.Assert.BP.CheckErrorPrevention' =
		() =>
		    PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships()
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// Formatting Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against formatting best practices
/// Asserts that visible measures should have their format string property assigned.
/// Measures without format strings may display inconsistently and make reports harder to understand.
function 'PQL.Assert.BP.ShouldProvideFormatStringForMeasures' =
		() =>
		    VAR _ViewMeasures = INFO.VIEW.MEASURES()
		    VAR _Measures = INFO.MEASURES()
		    VAR _Tables = INFO.VIEW.TABLES()
		    
		    // Create a lookup for hidden tables
		    VAR _HiddenTables = 
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )
		    
		    // Check measures for missing format strings
		    VAR _ViolatingMeasures = 
		        FILTER(
		            _ViewMeasures,
		            VAR _TableName = [Table]
		            VAR _MeasureID = [ID]
		            
		            // Get FormatString from INFO.MEASURES()
		            VAR _FormatString = 
		                MAXX(
		                    FILTER(
		                        _Measures,
		                        [ID] = _MeasureID
		                    ),
		                    [FormatString]
		                )
		            
		            // Check if table is hidden
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0
		            
		            // Measure is on a visible table and has no format string
		            RETURN 
		                NOT _TableIsHidden
		                && (ISBLANK(_FormatString) || _FormatString = "")
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingMeasures)
		    
		    VAR _MeasuresList = 
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "MEASURES WITHOUT FORMAT STRING FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _MeasuresList,
		            "ALL VISIBLE MEASURES HAVE FORMAT STRINGS ASSIGNED"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Formatting] Provide format string for measures",
		        "Expected", "All visible measures should have format strings assigned",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Visible measures should have their format string property assigned. Measures without format strings may display inconsistently and make reports harder to understand. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Asserts that numeric columns should have SummarizeBy set to None.
/// Numeric columns with SummarizeBy enabled may cause accidental aggregation in reports. Users should create explicit measures instead.
function 'PQL.Assert.BP.ShouldNotSummarizeNumericColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    
		    // Create a lookup for hidden tables
		    VAR _HiddenTables = 
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )
		    
		    // Check numeric columns with SummarizeBy not set to None
		    VAR _ViolatingColumns = 
		        FILTER(
		            _Columns,
		            VAR _TableName = [Table]
		            VAR _DataType = [DataType]
		            VAR _IsHidden = [IsHidden]
		            VAR _SummarizeBy = [SummarizeBy]
		            
		            // Check if table is hidden
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0
		            
		            // Column is numeric (Int64, Decimal, or Double)
		            VAR _IsNumeric = 
		                _DataType = "Integer"
		                || _DataType = "Currency"
		                || _DataType = "Number"
		            
		            // Check if SummarizeBy is not set to None
		            RETURN 
		                _IsNumeric
		                && NOT _IsHidden
		                && NOT _TableIsHidden
		                && _SummarizeBy <> "None"
		        )
		    
		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)
		    
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "] (SummarizeBy: " & [SummarizeBy] & ")",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    
		    VAR _Passed = _ViolationCount = 0
		    
		    VAR _ActualMessage = 
		        IF(
		            _ViolationCount > 0,
		            "NUMERIC COLUMNS WITH SUMMARIZE BY FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "ALL NUMERIC COLUMNS HAVE SUMMARIZE BY SET TO NONE"
		        )
		    
		    RETURN ROW(
		        "TestName", "[Formatting] Do not summarize numeric columns",
		        "Expected", "Numeric columns should have SummarizeBy set to None",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Numeric columns (Int64, Decimal, Double) should have their SummarizeBy property set to None to avoid accidental aggregation in Power BI. Users should create explicit measures instead. Severity: High (3)."
		    )	
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
/// Runs all formatting best practice checks.
/// This function executes all formatting validation rules and returns combined results.
function 'PQL.Assert.BP.CheckFormatting' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldProvideFormatStringForMeasures(),
		        PQL.Assert.BP.ShouldNotSummarizeNumericColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5


/// DAX Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against best practices and performance recommendations
/// Asserts that no bi-directional relationships exist on high-cardinality columns.
/// For high-cardinality columns (>1M distinct values), bi-directional relationships can impact performance.
function 'PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn' =
		() =>
		    VAR _CardinalityThreshold = 1000000
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _ColumnStats = COLUMNSTATISTICS()
		    VAR _BiDirectionalRels = 
		        FILTER(
		            _Relationships,
		            [CrossFilteringBehavior] = "BothDirections"
		        )
		    VAR _HighCardinalityBiDirRels = 
		        FILTER(
		            _BiDirectionalRels,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]
		            VAR _FromColumnCardinality = 
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _FromTable && [Column Name] = _FromColumn
		                    ),
		                    [Cardinality]
		                )
		            VAR _ToColumnCardinality = 
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _ToTable && [Column Name] = _ToColumn
		                    ),
		                    [Cardinality]
		                )
		            RETURN _FromColumnCardinality > _CardinalityThreshold || _ToColumnCardinality > _CardinalityThreshold
		        )
		    VAR _HighCardinalityCount = COUNTROWS(_HighCardinalityBiDirRels)
		    VAR _Passed = _HighCardinalityCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Avoid bi-directional relationships against high-cardinality columns",
		        "Expected", "No bi-directional relationships on high-cardinality columns (>1M)",
		        "Actual", IF(_HighCardinalityCount > 0, "BI-DIRECTIONAL RELATIONSHIPS ON HIGH-CARDINALITY COLUMNS FOUND (" & FORMAT(_HighCardinalityCount, "0") & ")", "NO HIGH-CARDINALITY BI-DIRECTIONAL RELATIONSHIPS"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid bi-directional relationships on high-cardinality columns (>1M distinct values) for better performance"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that auto-date tables should be removed.
/// Auto-date tables (DateTableTemplate_* and LocalDateTable_*) consume memory and should be disabled.
function 'PQL.Assert.BP.ShouldRemoveAutoDateTable' =
		() =>
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _AutoDateTableCount = 
		        COUNTROWS(
		            FILTER(
		                _Tables,
		                LEFT([Name], 18) = "DateTableTemplate_" || LEFT([Name], 15) = "LocalDateTable_"
		            )
		        )
		    VAR _Passed = _AutoDateTableCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Remove auto-date table",
		        "Expected", "No auto-date tables should exist in the model",
		        "Actual", IF(_AutoDateTableCount > 0, "AUTO-DATE TABLES FOUND (" & FORMAT(_AutoDateTableCount, "0") & ")", "NO AUTO-DATE TABLES"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using auto-date tables. Turn off auto-date table in Power BI Desktop settings to save memory"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that no columns use floating point data types.
/// The "Double" floating point data type should be avoided to prevent unpredictable roundoff errors and performance issues.
function 'PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _DoubleColumns = 
		        FILTER(
		            _Columns,
		            [DataType] = "Number"
		        )
		    VAR _DoubleColumnCount = COUNTROWS(_DoubleColumns)
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _DoubleColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _DoubleColumnCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _DoubleColumnCount > 0,
		            "NUMBER DATA TYPE COLUMNS FOUND (" & FORMAT(_DoubleColumnCount, "0") & "): " & _ColumnsList,
		            "NO NUMBER DATA TYPE COLUMNS"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Do not use floating point data types",
		        "Expected", "No columns should use Number data type",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using Number floating point data type, as it can result in unpredictable roundoff errors and decreased performance. Use Int64 or Decimal where appropriate (Decimal limited to 4 digits after decimal)"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Asserts that IsAvailableInMdx should be set to false on non-attribute hidden columns.
/// Hidden columns should have IsAvailableInMdx set to false for better performance.
function 'PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _ViolatingColumns = 
		        FILTER(
		            _Columns,
		            VAR _CurrentTable = [Table]
		            VAR _IsHidden = [IsHidden]
		            VAR _IsAvailableInMDX = [IsAvailableInMDX]
		            VAR _TableIsHidden = 
		                COUNTROWS(
		                    FILTER(_Tables, [Name] = _CurrentTable && [IsHidden] = TRUE)
		                ) > 0
		            RETURN
		                _IsAvailableInMDX = TRUE
		                && (_IsHidden = FALSE && _TableIsHidden = FALSE)
		        )
		    VAR _ViolatingColumnCount = COUNTROWS(_ViolatingColumns)
		    VAR _ColumnsList = 
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingColumnCount = 0
		    VAR _ActualMessage = 
		        IF(
		            _ViolatingColumnCount > 0,
		            "COLUMNS WITH ISAVAILABLEINMDX=TRUE FOUND (" & FORMAT(_ViolatingColumnCount, "0") & "): " & _ColumnsList,
		            "NO VIOLATING COLUMNS"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Set IsAvailableInMdx to false on non-attribute columns",
		        "Expected", "Hidden columns should have IsAvailableInMdx = false",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "To speed up processing time and conserve memory, attribute hierarchies should not be built for hidden columns. Set IsAvailableInMdx to false for better performance"
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5

/// Runs all performance best practice checks.
/// This function executes all performance validation rules and returns combined results.
function 'PQL.Assert.BP.CheckPerformance' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn(),
		        PQL.Assert.BP.ShouldRemoveAutoDateTable(),
		        PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes(),
		        PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.5
